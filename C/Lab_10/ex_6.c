/*-------------------------------------------------------------------<Header>-
 Name: ex_6.c
 Title: —
 Description: Напишіть програму, яка буде виконувати певні дії для декількох
 масивів з елементами типу integer. Оформіть код, як завершену програму та
 виведіть результати на екран. Один з масивів має заповнюватись елементами,
 кожен з яких буде дорівнювати сумі двох відповідних елементів
 (з тим самим індексом) інших двох масивів. Наприклад, у випадку коли ми маємо
 два масиви: перший з елементами значення – 2, 4, 5, 8, та другий з елементами,
 значення яких дорівнюють – 1, 0, 4, 6; значення елементів третього масиву
 будуть рахуватись таким чином: перший елемент: 2 + 1; другий елемент: 4 + 0;
 третій елемент: 5 + 4; четвертий елемент: 8 + 6. Відповідно третій масив буде
 складатись із таких значень, як: 3, 4, 9 і 14. Виконайте реалізацію поставлених
 задач. Подумайте та дайте відповідь на питання: чи можливо провести подібну
 операцію (складання або віднімання) у випадку, коли кількість елементів у
 масивах не дорівнюватиме одна одній; чи можливо подібне складання проводити
 для масивів двовимірного типу; якщо в задачі стоїть питання складання елементів
 одновимірного та двовимірного масивів – чи можливо це?
 -------------------------------------------------------------------</Header>-*/

#include <stdio.h>
#include <stdlib.h> // malloc, free

void fill_arrs(int n, int m, int **arr);
void sum_arrs(int n, int m, int **arr);
void show_arrs(int n, int m, int **arr);

int main(void) {
	int n, m;
	int **matrix; // matrix - pointer to an array of pointers
	char line[] = "==================";
	do {
		fseek(stdin, 0, SEEK_END); // buffer cleaning
		printf(" Enter the number of arrays: ");
	} while (!scanf("%d", &n));
	/* Allocating memory for a two-dimensional array - a matrix with n rows of m elements */
	matrix = (int**)malloc((n + 1) * sizeof(int*)); // (n + 1) for the result array
	if (!matrix) {
		puts(" Not Enough Memory");
	}
	else {
		do {
			fseek(stdin, 0, SEEK_END); // buffer cleaning
			printf(" Enter the size of the arrays: ");
		} while (!scanf("%d", &m));
		for (int i = 0; i <= n; i++) {
			matrix[i] = (int*)malloc(m * sizeof(int));
		}
		if (!matrix[n]) {
			puts(" Not Enough Memory");
		}
		else {
			fill_arrs(n, m, matrix);
			printf("%s\n", line);
			sum_arrs(n, m, matrix);
			show_arrs(n + 1, m, matrix);
			for (int i = 0; i < n; i++) {
				free(matrix[i]); // freeing up memory space
			}
		}
		free(matrix); // freeing up memory space
	}
	putchar('\n');
	return 0;
}

void fill_arrs(int n, int m, int **arr) {
	for (int i = 0; i < n; i++) {
		printf(" array #%d:\n", i + 1);
		for (int j = 0; j < m; j++) {
			do {
				fseek(stdin, 0, SEEK_END); // buffer cleaning
				printf("  element[%d] = ", j);
			} while (!scanf("%d", &arr[i][j]));
		}
	}
}

void sum_arrs(int n, int m, int **arr) {
	int s;
	for (int j = 0; j < m; j++) {
		s = 0; // sum of column
		for (int i = 0; i < n; i++) {
			s += arr[i][j];
		}
		arr[n][j] = s;
	}
}

void show_arrs(int n, int m, int **arr) {
	/* this function should not alter the array, it uses const */
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			printf("%4d", arr[i][j]);
		}
		putchar('\n');
	}
}

/*
Запитання № 1:
Якщо кількість елементів у масивах різна, то провести подібне складання не
можливо. Причина: якщо n-ий елемент масиву не ініціалізований, то в комірці
пам’яті міститься не те, що нам потрібно (це може бути сміття). Приклад: маємо
два масиви int a[3] = {0, 1, 2}; int b[2] = {0, 1}; b[2] – такого елемента не
існує в масиві b, тобто ми вийшли за його межі, і в такому випадку отримаємо
неочікуваний результат. З іншої сторони, якщо прийняти, що елемента не існує,
і просто нічого не потрібно додавати, то подібне складання проводити можна.
Приклад: два масиви int a[3] = {0, 1, 2}; int b[3] = {0, 1}; В цьому випадку під
масив b виділяємо пам’ять на 3 елементи. Так як вказано лише два елементи, то
всі інші (в цьому прикладі лише один) автоматично ініціалізуються нулями. Тобто
{0, 1, 0}. Тепер при поелементному складанні, нуль не вплине на результат,
результат буде коректним. Отже, головне слідкувати, щоб не відбувся вихід за
межі масиву.

Запитання № 2:
Так, подібне складання для двовимірних масивів проводити можна. Додаємо
відповідні елементи (номер рядка і номер стовпчика однієї матриці співпадає з
відповідним номером рядка і номером стовпчика іншої матриці). Головне, щоб
матриці мали однакові розміри, або ж ініціалізувати “неіснуючі” елементи нулями.

Запитання № 3:
Масиви мають різну розмірність, подібне додавання не має сенсу.
Одновимірний масив можна додати до якогось одного рядка матриці (за умови, що
пояснена в запитанні № 1), або до всіх почерзі, але це інший алгоритм. Якщо
до другого рядка матриці додавати другий рядок одновимірного масиву, якого не
існує, то звісно так робити не можна.
*/
