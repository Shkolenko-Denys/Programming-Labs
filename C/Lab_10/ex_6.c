/*-------------------------------------------------------------------<Header>-
 Name: ex_6.c
 Title: —
 Description: Напишіть програму, яка буде виконувати певні дії для декількох
 масивів з елементами типу integer. Оформіть код, як завершену програму та
 виведіть результати на екран. Один з масивів має заповнюватись елементами,
 кожен з яких буде дорівнювати сумі двох відповідних елементів
 (з тим самим індексом) інших двох масивів. Наприклад, у випадку коли ми маємо
 два масиви: перший з елементами значення – 2, 4, 5, 8, та другий з елементами,
 значення яких дорівнюють – 1, 0, 4, 6; значення елементів третього масиву
 будуть рахуватись таким чином: перший елемент: 2 + 1; другий елемент: 4 + 0;
 третій елемент: 5 + 4; четвертий елемент: 8 + 6. Відповідно третій масив буде
 складатись із таких значень, як: 3, 4, 9 і 14. Виконайте реалізацію поставлених
 задач. Подумайте та дайте відповідь на питання: чи можливо провести подібну
 операцію (складання або віднімання) у випадку, коли кількість елементів у
 масивах не дорівнюватиме одна одній; чи можливо подібне складання проводити
 для масивів двовимірного типу; якщо в задачі стоїть питання складання елементів
 одновимірного та двовимірного масивів – чи можливо це?
 -------------------------------------------------------------------</Header>-*/

#include <stdio.h>
#include <stdlib.h> // malloc, free

void fill_arrs(int n, int m, int **arr);
void sum_arrs(int n, int m, int **arr);
void show_arrs(int n, int m, int **arr);

int main(void) {
    int n, m;
    int **matrix; // matrix - pointer to an array of pointers
    char line[] = "==================";
    do {
        fseek(stdin, 0, SEEK_END); // buffer cleaning
        printf(" Enter the number of arrays: ");
    } while (!scanf("%d", &n));
    /* Allocating memory for a two-dimensional array - a matrix with n rows of m elements */
    matrix = (int**)malloc((n + 1) * sizeof(int*)); // (n + 1) for the result array
    if (!matrix) {
        puts(" Not Enough Memory");
    }
    else {
        do {
            fseek(stdin, 0, SEEK_END); // buffer cleaning
            printf(" Enter the size of the arrays: ");
        } while (!scanf("%d", &m));
        for (int i = 0; i <= n; i++) {
            matrix[i] = (int*)malloc(m * sizeof(int));
        }
        if (!matrix[n]) {
            puts(" Not Enough Memory");
        }
        else {
            fill_arrs(n, m, matrix);
            printf("%s\n", line);
            sum_arrs(n, m, matrix);
            show_arrs(n + 1, m, matrix);
            for (int i = 0; i < n; i++) {
                free(matrix[i]); // freeing up memory space
            }
        }
        free(matrix); // freeing up memory space
    }
    putchar('\n');
    return 0;
}

void fill_arrs(int n, int m, int **arr) {
    for (int i = 0; i < n; i++) {
        printf(" array #%d:\n", i + 1);
        for (int j = 0; j < m; j++) {
            do {
                fseek(stdin, 0, SEEK_END); // buffer cleaning
                printf("  element[%d] = ", j);
            } while (!scanf("%d", &arr[i][j]));
        }
    }
}

void sum_arrs(int n, int m, int **arr) {
    int s;
    for (int j = 0; j < m; j++) {
        s = 0; // sum of column
        for (int i = 0; i < n; i++) {
            s += arr[i][j];
        }
        arr[n][j] = s;
    }
}

void show_arrs(int n, int m, int **arr) {
    /* this function should not alter the array, it uses const */
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            printf("%4d", arr[i][j]);
        }
        putchar('\n');
    }
}

/*
Запитання № 1:
Якщо кількість елементів у масивах різна, то провести подібне складання не
можливо. Причина: якщо n-ий елемент масиву не ініціалізований, то в комірці
пам’яті міститься не те, що нам потрібно (це може бути сміття). Приклад: маємо
два масиви int a[3] = {0, 1, 2}; int b[2] = {0, 1}; b[2] – такого елемента не
існує в масиві b, тобто ми вийшли за його межі, і в такому випадку отримаємо
неочікуваний результат. З іншої сторони, якщо прийняти, що елемента не існує,
і просто нічого не потрібно додавати, то подібне складання проводити можна.
Приклад: два масиви int a[3] = {0, 1, 2}; int b[3] = {0, 1}; В цьому випадку під
масив b виділяємо пам’ять на 3 елементи. Так як вказано лише два елементи, то
всі інші (в цьому прикладі лише один) автоматично ініціалізуються нулями. Тобто
{0, 1, 0}. Тепер при поелементному складанні, нуль не вплине на результат,
результат буде коректним. Отже, головне слідкувати, щоб не відбувся вихід за
межі масиву.

Запитання № 2:
Так, подібне складання для двовимірних масивів проводити можна. Додаємо
відповідні елементи (номер рядка і номер стовпчика однієї матриці співпадає з
відповідним номером рядка і номером стовпчика іншої матриці). Головне, щоб
матриці мали однакові розміри, або ж ініціалізувати “неіснуючі” елементи нулями.

Запитання № 3:
Масиви мають різну розмірність, подібне додавання не має сенсу.
Одновимірний масив можна додати до якогось одного рядка матриці (за умови, що
пояснена в запитанні № 1), або до всіх почерзі, але це інший алгоритм. Якщо
до другого рядка матриці додавати другий рядок одновимірного масиву, якого не
існує, то звісно так робити не можна.
*/
